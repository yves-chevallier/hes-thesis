%///////////////////////////////////////////////////////////////////////////////
%//  _   _        _                            _                                
%// | | | |      |_|                          | |                               
%// | |_| |_____  _ _____           _     _ __| |                               
%// | |_  | ___ || |  _  \  _____  \ \  / // _  |                               
%// | | | | ____|| | |_| | (_____)  \ \/ /( (_| |                               
%// |_| |_|_____)|_|___  |           \__/  \____|                               
%//                  __| | Haute Ecole d'Ingenieurs                             
%//                 |___/  et de Gestion - Vaud                                 
%//                                                                             
%// @title    Mémoire de diplôme: Librairie JavaScript                          
%// @context  Travail de diplôme                                                
%// @author   Y. Chevallier <nowox@kalios.ch>                                   
%// @file     javascript.tex                                                    
%// @language ASCII/C                                                           
%// @svn      $Id$              
%///////////////////////////////////////////////////////////////////////////////
\chapter{Librairie JavaScript}
\label{chpjs}
\index{JavaScript}
\index{librairie}
\maraja{Orienté chaîne de caractère et objet}
A la section \ref{dynapage}, il a été établi que la réalisation d'une librairie JavaScript est nécessaire d'une part pour rendre possible le dialogue avec le démon et d'autre part pour assurer le dynamisme de la page. Ce langage étant orienté pour traiter des chaînes de caractères, concevoir un échange de données à l'aide de messages binaires n'est pas une bonne solution. D'autre part, la seule possibilité de JavaScript permettant de communiquer avec le monde extérieur c'est d'utiliser le protocole \textsf{HTTP}. C'est pour cette raison que nous allons nous y intéresser de plus près.

\section{HTTP en bref}
\index{http}
\maraja{HTTP pour le Web}
Le protocole \textsf{HTTP} est sans aucun doute le plus utilisé de part le monde. Il s'agit d'un protocole de la sixième couche \textsf{OSI}. Il s'appuie sur \textsf{TCP} un protocole de transport de la couche quatre. Malgré sa complexité, du point de vue de LonTouch, ce ne sont que les fonctionnalités de base qui seront utilisées. 

\subsection{Comprendre par l'exemple}
\index{telnet}
\index{google}
\maraja{Comment contacter Google en bas niveau}
C'est à l'aide d'un exemple simple que nous allons tenter de comprendre le fonctionnement du protocole \textsf{HTTP}. En imaginant que l'on souhaite effectuer une recherche sur Google sans utiliser de navigateur web, il faut faire appel à un outil de communication basé sur \textsf{TCP}. Pour la démonstration nous utiliserons \textsf{TELNET}. En règle générale cet outil est disponible sur toutes les plateformes informatiques. Sous Windows, c'est à l'aide du menu démarrer et de la commande ``Exécuter'' que l'on y accède. La figure \ref{exectelnet} montre visuellement comment exécuter cet outil. Une fois lancé, le programme est en attente d'une commande. Pour se connecter au moteur de recherche Google, utilisons celle-ci: 

\begin{lstlisting}
o www.google.ch 80
\end{lstlisting}

\fig{exectelnet}{Fenêtre permettant l'exécution de l'outil telnet}
\index{PORT}
La lettre \emph{o} pour \emph{open} puis l'adresse à contacter et enfin le \textsf{PORT} \textsf{TCP} sur lequel on veut tenter d'établir la connexion. Une fois la commande validée, nous sommes connectés avec le serveur de Google et celui-ci attends une commande \textsf{HTTP}. Nous allons utiliser ici un ``en-tête HTTP'' minimal pour permettre de charger la page habituellement accessible depuis \url{http://www.google.ch}. Voici la commande à envoyer au serveur pour effectuer une requête: 

\begin{lstlisting}
GET www.google.ch/ HTTP/1.0
\end{lstlisting}

Après deux validations successives à l'aide de la touche ``enter'' du clavier. Une première fois pour valider la saisie et une seconde pour soumettre la commande au serveur. A cet instant une certaine quantité de texte apparaît sur l'écran. Ce n'est que la première partie qui nous intéresse: 


\begin{lstlisting}
HTTP/1.0 200 OK
Cache-Control: private
Content-Type: text/html
Set-Cookie: PREF=ID=5c2ce178cf3e7b4d; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.fr
Server: GWS/2.1
Date: Sat, 17 Dec 2005 02:01:53 GMT
Connection: Close

<html>
   <head>
 ...
\end{lstlisting}

Ce qui a été reçu  n'est rien d'autre que la page de recherche de Google dans sa version \textsf{HTML} brut. Le code \textsf{HTML} est précédé d'un ``en-tête HTTP'' que nous pouvons observer ci-dessus. Ce qu'il faut comprendre c'est qu'en établissant une connexion \textsf{TCP} avec un serveur Web et en utilisant la commande \textsf{GET} du protocole \textsf{HTTP}, il est possible d'effectuer une requête à un serveur Web.  Selon  l'hypothèse que nous souhaitions effectuer une recherche pour le mot ``lontouch''. Il suffit alors d'utiliser la commande \textsf{HTTP} suivante: 

\begin{lstlisting}  
GET www.google.ch/search?q=lontouch  HTTP/1.0
\end{lstlisting}  

On observe ici que l'on s'adresse à un script nommé \emph{search} auquel on assigne au paramètre \emph{q} la valeur lontouch. Ce script va pouvoir traiter la demande et renvoyer un résultat. En l'occurrence, le nombre de résultats sera nul puisque le nom LonTouch n'est encore utilisé de personne. Ce qu'il faut retenir c'est qu'il est possible de véhiculer des informations à caractère variable au travers de l'\textsf{URL} ou \emph{Uniform Resource Locator}, autrement dit, de l'adresse \textsf{HTTP}. 

\subsection{Dialogue avec le démon} 
A l'aide de cette initiation à \textsf{HTTP}, il est possible, sans difficulté, de comprendre comment transférer des données au démon. En considérant une interface graphique permettant le contrôle d'un éclairage \textsf{LON} au travers d'une variable de type \textsf{SNVT}, nous savons que deux paramètres sont mis en jeu: L'intensité de l'éclairage à l'aide du paramètre \emph{value} et l'état binaire de la lampe avec le paramètre \emph{state}. Si l'on considère que l'adresse \url{http://www.lontouch.ch} est l'adresse du démon, la requête \textsf{HTTP} suivante pourrait permettre de mettre à jour l'état de l'éclairage: 

\begin{lstlisting}
GET www.lontouch.ch/snvt?value=128&state=1  HTTP/1.0
\end{lstlisting}  

\maraja{N'oublions pas TCP}
Le démon ne peut-être dans ce cas qu'un simple serveur \textsf{TCP} ne comprenant que certaines commandes primitives de \textsf{HTTP}. Quoi qu'il en soit, une information manque à la requête passée. Il n'est pas défini quel éclairage nous souhaitons commander. Il est donc nécessaire d'apporter à la requête une légère modification: 

\begin{lstlisting}
GET www.lontouch.ch/snvt?lamp1.value=128&lamp1.state=1  HTTP/1.0
\end{lstlisting}  

\maraja{Mise à jour des valeurs}
Jusqu'ici tout est relativement simple. Néanmoins, le démon doit pouvoir, à un moment ou un autre informer l'interface graphique des éventuels changements survenus sur le réseau \textsf{LON}. Etant donné qu'avec \textsf{HTTP} les questions sont toujours posées par le client et qu'il ne peut y avoir de réponse sans question. C'est  au navigateur supportant l'interface graphique d'effectuer auprès du démon une demande. Définissons alors une requête \textsf{HTTP} pour ce type de demande: 

\begin{lstlisting}  
GET www.lontouch.ch/snvt?update  HTTP/1.0
\end{lstlisting}  

\maraja{En domotique on s'accorde 300ms}
Pour que l'interface graphique puisse disposer sans cesse des dernières valeurs de la \textsf{SNVT}, elle lui suffit d'exécuter la commande ci-dessus périodiquement. En domotique ou immotique, on autorise des écarts de temps de $300[ms]$. Aussi, la requête update sera exécutée à cet intervalle de temps. Cependant, cette méthode consistant à envoyer périodiquement des demande à un serveur, appelée polling est mauvaise. En admettant qu'un millier d'interfaces graphiques soient réparties dans le bâtiment c'est alors plus de $9000$ requêtes qui sont reçue par le \textsf{SERVEUR} toute les secondes. C'est pour cette raison qu'un démon ``personnel'' est installé dans chacun des écrans tactiles. Celui-ci sera en mesure être informé directement depuis le \textsf{SERVEUR} lorsque l'état d'un périphérique \textsf{LON} change. 

\section{Format des réponses HTTP}
\index{eval}
\index{SOAP}
\maraja{la commande eval de JavaScript}
Une manière élégante pour structurer les informations émises par le démon serait d'utiliser le format \textsf{XML} ou \textsf{SOAP}. Cependant, ces formats sont lourds. L'information utile est noyée dans la structure du langage. D'autant plus que les analyses de données \textsf{XML} sont compliquées et requièrent des ressources système non indispensables. Une commande JavaScript très intéressante se nomme \emph{eval}. Elle permet d'évaluer une chaîne de caractère comme si il s'agissait de code JavaScript. 

\index{pseudo objet}
Ce langage est porté sur la notion d'objet ou tout au moins de ``pseudo objet''. L'auteur vous invite à suivre le lien mentionné dans le glossaire pour en savoir plus à propos du terme \textsf{OBJET}. 

\maraja{Un exemple de plus}
Pour expliquer quel est le format des réponses \textsf{HTTP} qui à été retenu et pourquoi, utilisons une fois de plus l'exemple. L'expression JavaScript suivante assigne à la variable \texttt{toto} la valeur $4$.

\begin{lstlisting}  
var toto = 4
\end{lstlisting}   

Rien n'empêche maintenant d'assigner à la variable \texttt{toto} un objet à deux propriétés. Dans l'exemple suivant, la propriété \texttt{tata} vaut $4$ et \texttt{titi} vaut $5$. 

\begin{lstlisting}  
var toto = {tata:4, titi:5}
\end{lstlisting}  

Ce format, simple, peut être appliqué à des structures \textsf{SNVT} comme le montre l'exemple suivant pour un type switch: 

\begin{lstlisting}
lamp1 = {state: 1, value: 130}
\end{lstlisting}          

Avec cette commande on défini que la variable \texttt{lamp1}, concerne un éclairage allumé à $65[\%]$. Si l'on fait l'hypothèse que le démon retourne à JavaScript une réponse similaire, la commande \emph{eval} peut permettre directement de mettre à jour l'état d'une variable \texttt{lamp1} locale à l'interface graphique. Nous verrons plus loin que le démon est en mesure de formater sa réponse selon plusieurs formats. Partant de ce fait, nous ajouterons le suffixe \texttt{.js} à l'\textsf{URL} pour indiquer que le format de réponse souhaité est celui que nous avons entraperçu ci-dessus: 

\begin{lstlisting}  
GET www.lontouch.ch/snvt.js?update  HTTP/1.0
\end{lstlisting}  

A titre d'information, voici ce que nous aurions reçu pour un format \textsf{XML} \\
(\texttt{GET www.lontouch.ch/snvt.xml?update  HTTP/1.0})

\begin{lstlisting}  
<snvt type="switch" name="lamp1">
<value>128</value>
 	<state>1</state>
</snvt>
\end{lstlisting}  
\maraja{JavaScript c'est Laurel et XML c'est Hardy}
Il est évident qu'en comparaison numérique  il faut $74$ caractères \textsf{ASCII}/\textsf{XML} contre $30$ pour le format JavaScript. 

Pour clore cette section sur le format des réponses \textsf{HTTP}, le protocole \textsf{LTP/HTTP} défini au chapitre \ref{chpltp}, défini l'ensemble des \textsf{URL} possibles ainsi que la structures des réponses.

\section{XMLHttpRequest}
\index{XMLHttpRequest}
\index{ActiveX}
\index{Gecko}
\maraja{XMLHttpRequest pour faire des requêtes}
Ce qui jusqu'ici n'a pas été abordé, c'est la manière dont l'interface graphique va pouvoir effectuer une demande au démon. Avec Gecko, une commande JavaScript nommée \textsf{XMLHttpRequest} existe. Il faut néanmoins savoir que cette commande n'est pas un standard du \textsf{W3C} de même que celle, similaire, disponible avec \emph{Microsoft Internet Explorer} (nécessitant un contrôle \textsf{ActiveX}). Pourtant une commande normalisée reconnue par le \textsf{W3C} est disponible mais elle n'est implémentée dans aucun navigateur. 

\maraja{XMLHttpRequest s'utilise de plus en plus}
\textsf{XMLHttpRequest} est à considérer comme un objet JavaScript permettant d'effectuer des requêtes \textsf{HTTP} auprès d'un serveur. Ces requêtes permettant à une application Web de recevoir des données et de mettre à jour la page dynamiquement sans avoir à la recharger dans le navigateur. Ce procédé est de plus en plus courant dans le monde du Web. 

Un objet est défini par ses méthodes et ses propriétés. Nous avons vu sommairement dans la section précédente qu'une propriété peut prendre une valeur tandis qu'une méthode est semblable à un outil auquel on fourni des paramètres et qui nous retourne un résultat. Dans la librairie que nous souhaitons concevoir, ce ne sont que certaines méthodes de l'objet \textsf{XMLHttpRequest} qui vont être utilisées.  

\subsection{Methodes utilisées}
\index{methodes}
\begin{description}
\index{open}
\item{\texttt{open("mode", "url", "syncFlag", "login", "password")}} \mbox{}\linebreak
Cette méthode permet l'ouverture d'une connexion avec le serveur dont l'adresse est fournie par le paramètre url. Le mode utilisé pour effectuer la requête sera GET. Concernant les paramètres suivant, ils ne sont pas indispensables ici. 

\index{send}
\item{\texttt{send("content")}}\mbox{}\linebreak
	Permet d'envoyer une requête \emph{content} au serveur après avoir établi préalablement une connexion à l'aide de la méthode \emph{open}. 
\end{description} 
\index{propriétés}
\subsection{Propriétés utilisées}

\begin{description}
\index{onreadystatechange}
\item{\texttt{onreadystatechange}}\mbox{}\linebreak
Cette propriété permet de définir une commande JavaScript qui sera appelée lorsqu'une réponse sera reçue du serveur. 

\index{readyState}
\item{\texttt{readyState}}\mbox{}\linebreak
	Retourne l'état d'une réponse sous forme numérique: \\
	$0$ = non initialisé (demande non envoyée) \\
	$1$ = en cours de chargement \\
	$2$ = réponse en cours \\
	$3$ = réception en cours (interactive) \\
	$4$ = réception complète. 

\index{responseText}
\item{\texttt{responseText}}\mbox{}\linebreak
Contient le texte de réponse du serveur. C'est ce texte sur lequel il va falloir utiliser la commande eval. 

\index{status}
\item{\texttt{status}}\mbox{}\linebreak
	Retourne le code \textsf{HTTP} de la réponse. Il faut simplement retenir que : \\
	$200$ = Tout va bien \\
	$404$ = Page non trouvée \\
	$403$ = Accès Interdit 

\end{description} 

\index{erreur 404}
%\maraja{404 c'est pas trouvé, 200 c'est tout bon}
En temps normal et si le serveur est opérationnel c'est toujours le code $200$ qui sera reçu. En entrant dans votre navigateur l'adresse suivante: \\
\url{http://en.wikipedia.org/une_page_qui_existe_pas.html}, vous allez voir apparaître une erreur de type 404. 

\section{Méthodes pour le concepteur d'interfaces} 
\index{Macromedia Dreamweaver}
\maraja{Développer sans connaître JavaScript}
La réalisation d'interfaces graphiques nécessite une bonne connaissance de \textsf{HTML} et de \textsf{CSS}, mais pas de JavaScript. C'est d'ailleurs l'une des principales raisons du développement de la librairie. Elle doit permettre d'assigner de façon simple un comportement à un élément du code \textsf{HTML}. Il est même envisageable d'utiliser un logiciel de composition Web tel que \emph{Macromedia Dreamweaver} pour réaliser cette fois-ci sans connaissances ni de \textsf{HTML} ni de \textsf{CSS} une interface graphique. Avec ce type de logiciel, il est même possible de définir des macros qui peuvent contenir le code JavaScript relatif au  comportement souhaité.  Essayons d'abord de définir les possibilités offertes par la librairie. 

\index{Références aux SNVT}
\maraja{Adapté aux pros comme aux nuls}
L'utilisation de JavaScript implique de travailler avec des objets, lesquels contiennent des méthodes et des propriétés. Il faut donc mettre à disposition du concepteur d'interface, des objets correspondant à un contrôle tel qu'un bouton, faisant référence à une \textsf{SNVT}. Ces contrôles sont disponibles avec des comportements prédéfinis, lors d'un clic ou d'un survol de souris. Une possibilité d'édition de ses actions prédéfinies doit également être rendue possible. Le profane peut alors utiliser les contrôles sans en modifier le comportement et l'initié doit avoir la possibilité de l'éditer dans sa totalité. 

\subsection{Modifier ou lire les valeurs d'un contrôle}
Supposons qu'un contrôle, (un objet) de type \emph{SNVT\_switch} est défini. Des méthodes indispensables telles que les suivantes sont à disposition de l'utilisateur. Elles permettent de modifier les propriétés internes de l'objet:

\begin{itemize}
	\item State(\ldots)
	\item Value(\ldots)
\end{itemize}

On parle plus volontier de \emph{setter} et de \emph{getter}. 

Pour créer un contrôle de type bouton sur l'élément HTML suivant: 
\begin{lstlisting}[language=HTML]
<div id="bouton">Je suis un bouton cliquer moi dessus</div>
\end{lstlisting}
	
Il suffit d'écrire en JavaScript ceci:
\begin{lstlisting}
bouton1 = new SNVT_switch("bouton", "variable1")
\end{lstlisting}

Le mot clé \emph{new} signifie que l'on souhaite attribuer à la variable \emph{bouton1} une instance d'un objet nommé \emph{SNVT\_switch}. Lequel reçoit lors de sa création un premier paramètre correspondant au nom de l'élément \textsf{HTML} concerné (dans le cas présent bouton car l'identifiant de la balise \textsf{HTML} \emph{div} à été arbitrairement nommé ``bouton''), et un second paramètre liant l'élément à une variable qui sera, plus tard, interconnectée avec un périphérique LonWorks de même type que l'objet crée.

\fig{intercon}{La librairie permet l'interconnexion d'un élément HTML et d'une variable LonTouch}
Si l'on souhaite initialiser la variable variable1 comme étant allumée à $50[\%]$ il faut écrire:

\begin{lstlisting}  
bouton1.State(1)
bouton1.Value(100)
\end{lstlisting}  

Réciproquement, si l'on souhaite affecter à une variable toto la valeur 55 on procédera de cette manière:

\begin{lstlisting}
var toto = bouton1.State()
\end{lstlisting}  

\subsection{Modification CSS lors d'évènements du DOM}
\index{DOM}
\index{styles}
\maraja{On sonne JavaScript}
Lorsqu'un clic de souris, un survol ou même un double clic survient sur un élément \textsf{HTML}. Un évènement est généré à l'intérieur de JavaScript. La librairie capture les évènements qui surviennent sur élément \textsf{HTML} auquel on a assigné un contrôle. Ceci permet de modifier automatiquement le style \textsf{CSS} de l'élément. Pour prendre à nouveau exemple sur le contrôle de type \emph{SNVT\_switch} les cas de figures suivants sont prédéfinis: 

\begin{itemize}
	\item	Changement de style lorsque la lampe est allumée
	\item	Changement de style lorsque la lampe est éteinte
	\item	Changement de style lors d'un survol de souris sur l'élément lorsque la lampe est allumée
	\item	Changement de style lors d'un survol de souris sur l'élément lorsque la lampe est éteinte		
\end{itemize}

\maraja{Une apparence pour chaque situation}
En supposant que l'on souhaite appliquer le style \textsf{CSS} \emph{couleur\_rouge} lorsque la propriété state du contrôle vaut $0$ et le style \emph{couleur\_vert} lorsque cette propriété vaut $1$. Ainsi que les styles \emph{couleur\_rouge\_clair} lors que le pointeur de souris survole le bouton alors que la lampe (la propriété \emph{state}) est éteinte, et \emph{couleur\_vert\_clair} dans le cas similaire mais lorsque la lampe est allumée, voici le code JavaScript à écrire: 

\begin{lstlisting}  
bouton1.EventCSS('classOverOn', "couleur_vert_clair")
bouton1.EventCSS('classOverOff', "couleur_rouge_clair")
bouton1.EventCSS('classOutOn', "couleur_vert")
bouton1.EventCSS('classOutOff', "couleur_rouge")
\end{lstlisting}  

\subsection{Modifications avancées}
Il peut arriver que l'initié veuille modifier le comportement par défaut appliqué au contrôle \emph{bouton1} lors, par exemple, d'un clic de souris. Il voudrait afficher une alerte dans une fenêtre du navigateur web. La possibilité offerte par la librairie est la suivante: 

\begin{lstlisting}  
bouton1.Event('onclick', "alert('vous venez de cliquez sur un contrôle de type SNVT switch')")
\end{lstlisting}  


La méthode \texttt{Event} concernant le contrôle \texttt{bouton1} est appelée, recevant un premier paramètre qui définit sur quel type d'évènement modifier le comportement et en second paramètre l'action à effectuer. Ici, il s'agit d'exécuter la commande JavaScript \texttt{alert} qui affiche un message d'erreur dont le contenu est passé en paramètre. 

\subsection{Contrôle SNVT\_switch}
La figure \ref{objjs} présente un aperçu de l'ensemble des méthodes possibles pour l'objet \emph{SNVT\_switch}. 

\fig{objjs}{Aperçu des méthodes pour \emph{SNVT\_switch}}
\subsection{Les autres types de contrôles}
\maraja{Pour l'instant il n'y a que SNVT\_switch à se mettre sous la dent}
Faute de temps, la librairie ne compte actuellement qu'un seul type de contrôle. Toutefois, il est par la suite possible d'en créer d'autres en se basant sur celui existant. 
