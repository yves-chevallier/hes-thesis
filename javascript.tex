%///////////////////////////////////////////////////////////////////////////////
%//  _   _        _                            _                                
%// | | | |      |_|                          | |                               
%// | |_| |_____  _ _____           _     _ __| |                               
%// | |_  | ___ || |  _  \  _____  \ \  / // _  |                               
%// | | | | ____|| | |_| | (_____)  \ \/ /( (_| |                               
%// |_| |_|_____)|_|___  |           \__/  \____|                               
%//                  __| | Haute Ecole d'Ingenieurs                             
%//                 |___/  et de Gestion - Vaud                                 
%//                                                                             
%// @title    Mémoire de diplôme: Librairie JavaScript                          
%// @context  Travail de diplôme                                                
%// @author   Y. Chevallier <nowox@kalios.ch>                                   
%// @file     javascript.tex                                                    
%// @language ASCII/C                                                           
%// @svn      $Id$              
%///////////////////////////////////////////////////////////////////////////////
\chapter{Librairie JavaScript}
\label{chpjs}
A la section [refsection], il a été établi que la réalisation d'une librairie JavaScript est nécessaire d'une part pour rendre possible le dialogue avec le démon et d'autre part pour assurer le dynamisme de la page. Ce langage étant orienté pour traiter des chaînes de caractères, concevoir un échange de données à l'aide de messages binaires n'est pas une bonne solution. D'autre part, la seule possibilité de JavaScript permettant de communiquer avec le monde extérieur c'est d'utiliser le protocole HTTP. C'est pour cette raison que nous allons nous y intéresser de plus près.

\section{HTTP en bref}
Le protocole HTTP sans aucun doute le plus utilisé de part le monde. Il s'agit d'un protocole de la sixième couche OSI il s'appuie sur TCP un protocole de transport de la couche quatre. Malgré sa complexité, du point de vue de LonTouch, ce ne sont que les fonctionnalités de base qui seront utilisées. 

\subsection{Comprendre par l'exemple}
C'est à l'aide d'un exemple simple que nous allons tenter de comprendre le fonctionnement du protocole HTTP. En imaginant que l'on souhaite effectuer une recherche sur Google sans utiliser de navigateur web, il faut faire appel à un outil de communication basé sur TCP. Pour la démonstration nous utiliserons TELNET. En règle générale cet outil est disponible sur toutes les plateformes informatiques. Sous Windows, c'est à l'aide du menu démarrer et de la commande "Exécuter" que l'on y accède. La figure [reffigure] montre visuellement comment exécuter cet outil. Une fois lancé, le programme est en attente d'une commande. Pour se connecter au moteur de recherche Google, utilisons celle-ci: 

\begin{lstlisting}
o www.google.ch 80
\end{lstlisting}

La lettre o pour open puis l'adresse à contacter et enfin le port TCP sur lequel on veut tenter d'établir la connexion. Une fois la commande validée, nous sommes connectés avec le serveur de Google et celui-ci attends une commande HTTP. Nous allons utiliser ici un "en-tête HTTP" minimal pour permettre de charger la page habituellement accessible depuis http://www.google.ch. Voici la commande à envoyer au serveur pour effectuer une requête: 

\begin{lstlisting}
GET www.google.ch/ HTTP/1.0
\end{lstlisting}

Après deux validations successives à l'aide de la touche "enter" du clavier. Une première fois pour valider la saisie et une seconde pour soumettre la commande au serveur. A cet instant une certaine quantité de texte apparaît alors. Ce n'est que la première partie qui nous intéresse ici: 


\begin{lstlisting}
HTTP/1.0 200 OK
Cache-Control: private
Content-Type: text/html
Set-Cookie: PREF=ID=5c2ce178cf3e7b4d; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.fr
Server: GWS/2.1
Date: Sat, 17 Dec 2005 02:01:53 GMT
Connection: Close

<html>
   <head>
 ...
\end{lstlisting}

Ce qui a été reçu  n'est rien d'autre que la page de recherche de Google dans sa version HTML brut. Le code HTML est précédé d'un "en-tête HTTP". Celui que nous pouvons observer ci-dessus. Ce qu'il faut comprendre c'est qu'en établissant une connexion TCP avec un serveur web et en utilisant la commande GET du protocole HTTP, il est possible d'effectuer une requête à un serveur web.  Selon  l'hypothèse que nous souhaitions effectuer une recherche pour le mot "lontouch". Il suffit alors d'utiliser la commande HTTP suivante: 

\begin{lstlisting}  
GET www.google.ch/search?q=lontouch  HTTP/1.0
\end{lstlisting}  

On observe ici que l'on s'adresse à un script nommé \emph{search} auquel on assigne au paramètre \emph{q} la valeur lontouch. Ce script va pouvoir ensuite traiter la demande et renvoyer un résultat. En l'occurrence, le nombre de résultats sera nul puisque le nom LonTouch n'est encore utilisé de personne. Ce qu'il faut retenir c'est qu'il est possible de véhiculer des informations à caractère variable au travers de l'URL ou Uniform Resource Locator, autrement dit, de l'adresse HTTP. 

\subsection{HTTP pour dialoguer avec le démon} 
A l'aide de cette initiation à HTTP, il est possible, sans difficulté, de comprendre comment transférer des données au démon. En considérant une interface graphique permettant le contrôle d'un éclairage LON au travers d'une variable de type SNVT, nous savons que deux paramètres sont mis en jeu: L'intensité de l'éclairage à l'aide du paramètre value et l'état binaire de la lampe avec le paramètre state. Si l'on considère que l'adresse http://www.lontouch.ch est l'adresse du démon, la requête HTTP suivante pourrait permettre de mettre à jour l'état de l'éclairage: 

\begin{lstlisting}
GET www.lontouch.ch/snvt?value=128&state=1  HTTP/1.0
\end{lstlisting}  


Le démon ne peut-être dans ce cas qu'un simple serveur TCP ne comprenant que certaines commandes primitives de HTTP. Quoi qu'il en soit, une information manque à la requête passée. Il n'est pas défini quel éclairage nous souhaitons commander. Il est donc nécessaire d'apporter à la requête une légère modification: 

\begin{lstlisting}
GET www.lontouch.ch/snvt?lamp1.value=128&lamp1.state=1  HTTP/1.0
\end{lstlisting}  


Jusqu'ici tout est relativement simple. Néanmoins, le démon doit pouvoir, à un moment ou un autre informer l'interface graphique des éventuels changements survenus sur le réseau LON. Etant donné qu'avec HTTP les questions sont toujours posées par le client et qu'il ne peut y avoir de réponse sans question. C'est  au navigateur supportant l'interface graphique d'effectuer auprès du démon une demande. Définissons alors une requête HTTP pour ce type de demande: 

\begin{lstlisting}  
GET www.lontouch.ch/snvt?update  HTTP/1.0
\end{lstlisting}  

Pour que l'interface graphique puisse disposer sans cesse des dernières valeurs de la SNVT, elle lui suffit d'exécuter la commande ci-dessus périodiquement. En domotique ou immotique, on autorise des écarts de temps de 300[ms]. Aussi, la requête update sera exécutée à cet intervalle de temps. Cependant, cette méthode consistant à envoyer périodiquement des demande à un serveur, appelée polling est mauvaise. En admettant qu'un millier d'interfaces graphiques soient réparties dans le bâtiment c'est alors plus de 9000 requêtes qui sont reçue par le SERVEUR toute les secondes. C'est pour cette raison qu'un démon "personnel" est installé dans chacun des écrans tactiles. Celui-ci sera en mesure être informé directement depuis le SERVEUR lorsque l'état d'un périphérique LON change. 

\section{Format des réponses HTTP}
Une manière élégante pour structurer les informations émises par le démon serait d'utiliser le format XML ou SOAP. Cependant, ces formats sont lourds. L'information utile est noyée dans la structure du langage. D'autant plus que les analyses de données XML sont compliquées et requièrent des ressources système non indispensables. Une commande JavaScript très intéressante se nomme eval. Elle permet d'évaluer une chaîne de caractère comme si il s'agissait de code JavaScript. 

Ce langage est porté sur la notion d'objet ou tout au moins de "pseudo objet". L'auteur vous invite à suivre le lien mentionné dans le glossaire pour en savoir plus à propos du terme OBJET. 

Pour expliquer quel est le format des réponses HTTP qui à été retenu et pourquoi, utilisons une fois de plus l'exemple. L'expression JavaScript suivante assigne à la variable toto la valeur 4.

\begin{lstlisting}  
var toto = 4
\end{lstlisting}   

Rien n'empêche maintenant d'assigner à la variable toto un objet à deux propriétés. Dans l'exemple suivant, la propriété tata vaut 4 et titi vaut 5. 

\begin{lstlisting}  
var toto = {tata:4, titi:5}
\end{lstlisting}  

Ce format, simple, peut être appliqué à des structures SNVT comme le montre l'exemple suivant pour un type switch: 

\begin{lstlisting}
lamp1 = {state: 1, value: 130}
\end{lstlisting}          

Avec cette commande on défini que la variable lamp1, concerne un éclairage allumé à $65[\%]$. Si l'on fait l'hypothèse que le démon retourne à JavaScript une réponse similaire, la commande eval peut permettre directement de mettre à jour l'état d'une variable lamp1 locale à l'interface graphique. Nous verrons plus loin que le démon est en mesure de formater sa réponse selon plusieurs formats. Partant de ce fait, nous ajouterons le suffixe .js à l'URL pour indiquer que le format de réponse souhaité est celui que nous avons entraperçu ci-dessus: 

\begin{lstlisting}  
GET www.lontouch.ch/snvt.js?update  HTTP/1.0
\end{lstlisting}  

A titre d'information, voici ce que nous aurions reçu pour un format XML \\
(\texttt{GET www.lontouch.ch/snvt.xml?update  HTTP/1.0})

\begin{lstlisting}  
<snvt type="switch" name="lamp1">
<value>128</value>
 	<state>1</state>
</snvt>
\end{lstlisting}  

Il est évident qu'en comparaison numérique  il faut 74 caractères ASCII/XML contre 30 pour le format JavaScript. Pour clore cette section sur le format des réponses HTTP, le protocole LTP/HTTP défini au chapitre [refchapter], défini l'ensemble des URL possibles ainsi que la structures des réponses.

\section{XMLHttpRequest}
Ce qui jusqu'ici n'a pas été abordé, c'est la manière dont l'interface graphique va pouvoir effectuer une demande au démon. Avec Gecko, une commande JavaScript nommée XMLHttpRequest existe. Il faut néanmoins savoir que cette commande n'est pas un standard du w3c de même que celle, similaire, disponible avec Microsoft Internet Explorer (nécessitant un contrôle ActiveX). Pourtant une commande normalisée reconnue par le w3c est disponible mais elle implémentée dans aucun navigateur. 

XMLHttpRequest est à considérer comme un objet JavaScript permettant d'effectuer des requêtes HTTP auprès d'un serveur. Ces requêtes permettant à une application web de recevoir des données et de mettre à jour la page dynamiquement sans avoir à la recharger dans le navigateur. Ce procédé est de plus en plus courant dans le monde du web. 

Un objet est défini par ses méthodes et ses propriétés. Nous avons vu sommairement dans la section précédente qu'une propriété peut prendre une valeur tandis qu'une méthode est semblable à un outil auquel on fourni des paramètres et qui nous retourne un résultat. Dans la librairie que nous souhaitons concevoir, ce ne sont que certaines méthodes de l'objet XMLHttpRequest qui vont être utilisées.  

\subsection{Methodes utilisées}

\begin{description}
\item{\textsf{open("mode", "url", "syncFlag", "login", "password")}} \mbox{}\linebreak
Cette méthode permet l'ouverture d'une connexion avec le serveur dont l'adresse est fournie par le paramètre url. Le mode utilisé pour effectuer la requête sera GET. Concernant les paramètres suivant, ils ne sont pas indispensables ici. 

\item{\textsf{send("content")}}\mbox{}\linebreak
Permet d'envoyer une requête content au serveur après avoir établi préalablement une connexion à l'aide de la méthode open. 
\end{description} 

\subsection{Propriétés utilisées}

\begin{description}
\item{\textsf{onreadystatechange}}\mbox{}\linebreak
Cette propriété permet de définir une commande JavaScript qui sera appelée lorsqu'une réponse sera reçue du serveur. 

\item{\textsf{readyState}}\mbox{}\linebreak
	Retourne l'état d'une réponse sous forme numérique: \\
	0 = non initialisé (demande non envoyée) \\
	1 = en cours de chargement \\
	2 = réponse en cours \\
	3 = réception en cours (interactive) \\
	4 = réception complète. 

\item{\textsf{responseText}}\mbox{}\linebreak
Contient le texte de réponse du serveur. C'est ce texte sur lequel il va falloir utiliser la commande eval. 

\item{\textsf{status}}\mbox{}\linebreak
	Retourne le code HTTP de la réponse. Il faut simplement retenir que : \\
	200 = Tout va bien \\
	404 = Page non trouvée \\
	403 = Accès Interdit 

\end{description} 

En temps normal et si le serveur est opérationnel c'est toujours le code 200 qui sera reçu. En entrant dans votre navigateur l'adresse suivante: \url{http://en.wikipedia.org/une_page_qui_existe_pas.html}, vous allez voir apparaître une erreur de type 404. 

\section{Méthodes et propriétés pour le concepteur d'interfaces} 
La réalisation d'interfaces graphiques nécessite une bonne connaissance de HTML et de CSS, mais pas de JavaScript. C'est d'ailleurs l'une des principales raisons du développement de la librairie. Elle doit permettre d'assigner de façon simple un comportement à un élément du code HTML. Il est même envisageable d'utiliser un logiciel de composition web tel que \emph{Macromedia Dreamweaver} pour réaliser cette fois-ci sans connaissances ni de HTML ni de CSS une interface graphique. Avec ce type de logiciel, il est possible de définir des macros qui peuvent contenir le code JavaScript relatif au  comportement souhaité.  Essayons d'abord de définir les possibilités offertes par la librairie. 

L'utilisation de JavaScript implique de travailler avec des objets, lesquels contiennent des méthodes et des propriétés. Il faut donc mettre à disposition du concepteur d'interface, des objets correspondant à un contrôle tel qu'un bouton, faisant référence à une SNVT. Ces contrôles sont disponibles avec des comportements prédéfinis, lors d'un clic ou d'un survol de souris. Une possibilité d'édition de ses actions prédéfinies doit également être rendue possible. Le profane peut alors utiliser les contrôles sans en modifier le comportement et l'initié doit être en mesure de l'éditer dans sa totalité. 

\subsection{Modifier ou lire les valeurs d'un contrôle}
Supposons qu'un contrôle, (un objet) de type SNVT\_switch est défini. Des méthodes indispensables telles que les suivantes sont à disposition de l'utilisateur. Elles permettent de modifier les propriétés internes de l'objet:

\begin{itemize}
	\item State(\ldots)
	\item Value(\ldots)
\end{itemize}

Pour créer un contrôle de type bouton sur l'élément HTML suivant: 
\begin{center}\textsf{<div id="bouton">Je suis un bouton cliquer moi dessus</div>}\end{center}
	
Il suffit d'écrire en JavaScript ceci:
\begin{center}\textsf{bouton1 = new SNVT\_switch("bouton", "variable1")}\end{center}

Le mot clé new signifie que l'on souhaite attribuer à la variable bouton1 une instance d'un objet nommé SNVT\_switch. Lequel reçoit lors de sa création un premier paramètre correspondant au nom de l'élément HTML concerné (dans le cas présent bouton car l'identifiant de la balise HTML div à été arbitrairement nommé bouton), et un second paramètre liant l'élément à une variable qui sera, plus tard, interconnectée avec un périphérique LonWorks de même type que l'objet crée.

Si l'on souhaite initialiser la variable variable1 comme étant allumée à $50[\%]$ il faut écrire:

\begin{lstlisting}  
bouton1.State(1)
bouton1.Value(100)
\end{lstlisting}  

Réciproquement, si l'on souhaite affecter à une variable toto la valeur 55 on procédera de cette manière:

\begin{lstlisting}
var toto = bouton1.State()
\end{lstlisting}  

\subsection{Modification des styles CSS lors d'évènements du DOM}
Lorsqu'un clic de souris, un survol ou même un double clic survient sur un élément HTML. Un évènement est généré à l'intérieur de JavaScript. La librairie capture les évènements qui surviennent sur élément HTML auquel on a assigné un contrôle. Ceci permet de modifier automatiquement le style CSS de l'élément. Pour prendre à nouveau exemple sur le contrôle de type SNVT\_switch les cas de figures suivants sont prédéfinis: 

\begin{itemize}
	\item	Changement de style lorsque la lampe est allumée
	\item	Changement de style lorsque la lampe est éteinte
	\item	Changement de style lors d'un survol de souris sur l'élément lorsque la lampe est allumée
	\item	Changement de style lors d'un survol de souris sur l'élément lorsque la lampe est éteinte		
\end{itemize}

En supposant que l'on souhaite appliquer le style CSS \emph{couleur\_rouge} lorsque la propriété state du contrôle vaut 0 et le style \emph{couleur\_vert} lorsque cette propriété vaut 1. Ainsi que les styles \emph{couleur\_rouge\_clair} lors que le pointeur de souris survole le bouton alors que la lampe (la propriété state) est éteinte, et \emph{couleur\_vert\_clair} dans le cas similaire mais lorsque la lampe est allumée, voici le code JavaScript à écrire: 

\begin{lstlisting}  
bouton1.EventCSS('classOverOn', "couleur_vert_clair")
bouton1.EventCSS('classOverOff', "couleur_rouge_clair")
bouton1.EventCSS('classOutOn', "couleur_vert")
bouton1.EventCSS('classOutOff', "couleur_rouge")
\end{lstlisting}  

La figure [reffigure] permet d'illustrer graphiquement le cas présenté. 

\subsection{Modifications avancées}
Il peut arriver que l'initié veuille modifier le comportement par défaut appliqué au contrôle bouton1 lors, par exemple, d'un clic de souris. Il voudrait afficher une alerte dans une fenêtre du navigateur web. La possibilité offerte par la librairie est la suivante: 

\begin{lstlisting}  
bouton1.Event('onclick', "alert('vous venez de cliquez sur un contrôle de type SNVT switch')")
\end{lstlisting}  


La méthode Event concernant le contrôle bouton1 est appelée, recevant un premier paramètre qui définit sur quel type d'évènement modifier le comportement et en second paramètre l'action à effectuer. Ici, il s'agit d'exécuter la commande JavaScript alert qui affiche un message d'erreur dont le contenu est passé en paramètre. 

\subsection{Possibilités pour un contrôle SNVT\_switch}
La figure [reffigure] présente un aperçu de l'ensemble des méthodes possibles pour l'objet SNVT\_switch. 

\subsection{Les autres types de contrôles}
Faute de temps, la librairie ne compte actuellement qu'un seul type de contrôle. Toutefois, il est par la suite possible d'en créer d'autres en se basant sur celui existant. 
