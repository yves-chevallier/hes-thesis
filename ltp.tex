%///////////////////////////////////////////////////////////////////////////////
%//  _   _        _                            _                                
%// | | | |      |_|                          | |                               
%// | |_| |_____  _ _____           _     _ __| |                               
%// | |_  | ___ || |  _  \  _____  \ \  / // _  |                               
%// | | | | ____|| | |_| | (_____)  \ \/ /( (_| |                               
%// |_| |_|_____)|_|___  |           \__/  \____|                               
%//                  __| | Haute Ecole d'Ingenieurs                             
%//                 |___/  et de Gestion - Vaud                                 
%//                                                                             
%// @title    Mémoire de diplôme: Protocole de communication                    
%// @context  Travail de diplôme                                                
%// @author   Y. Chevallier <nowox@kalios.ch>                                   
%// @file     ltp.tex                                                           
%// @language ASCII/C                                                           
%// @svn      $Id$                     
%///////////////////////////////////////////////////////////////////////////////
\chapter{Protocole de communication}
\maraja{Décisions arbitraires}
Le protocole de communication est un élément de taille du projet LonTouch. Le terme \textsf{LTP} à été choisis pour \emph{LonTouch Protocol} il fait référence au protocole \textsf{LTP/HTTP} et \textsf{LTP/UDP}. Le premier à été entre-aperçu lors du chapitre \ref{chpjs}. Les décisions aboutissant au protocole final ont fait l'objet de longues décisions. Les possibilités quant à l'écriture d'un protocole de communication sont si vastes qu'il faut parfois prendre des mesures décisionnelles arbitraires pour éviter de rester immobile dans l'avancement du projet. 

\maraja{Un protocole bas niveau}
Lors d'un premier jet, seule la version \textsf{HTTP} du protocole à été envisagée. Cependant, en raison du trafic réseau nécessaire à la bonne marche de l'installation, il à été convenu de pourvoir les \textsf{TP} d'un démon local. A partir de ce moment l'utilisation d'un protocole de communication \textsf{ASCII} n'était plus justifiée. D'une part, les démons étant écris en \textsf{C}, il est plus facile de raisonner en terme de bits plutôt qu'en terme de chaines de caractères. Et d'autre part, il est plus raisonnable d'optimiser un maximum le rapport entre la quantité d'information réellement transmise et celle effective. Par conséquent, c'est auprès d'un protocole de plus bas niveau que les idées se sont portées. 

\maraja{LON est lent}
Notons qu'au début du projet, il n'était pas envisagé d'utiliser le réseau LonWorks comme canal de communication entre le \textsf{SERVEUR} et ses \textsf{TP}. En raison de la vitesse de transmission limitée à $78[kbits/sec]$ sur \textsf{LON}, l'argument en faveur d'une transmission la plus réduite possible est pleinement justifiable.

\maraja{LON et les messages explicites}
Sur LonWorks, le transfert d'informations par message explicites peut être mis au même niveau que le protocole \textsf{IP}. En outre, ce procédé offert par le protocole LonTalk est un moyen sûr d'échange d'information puisqu'il est possible de travailler en mode acquitté. Cette similitude avec Ethernet étant possible, ce chapitre sera consacré principalement au mode de communication Ethernet. 

\section{UDP plutôt que TCP}
\maraja{TCP est un boulet}
Au niveau \textsf{OSI}, la couche $4$ décrit deux protocoles de transports fondamentaux, mais très différents l'un de l'autre. \textsf{TCP} est un protocole considéré comme sûr. L'ordre des paquets émis puis reçu est contrôlé. L'intégrité des données est assurée. Malheureusement en termes de rendement il s'agit d'un ``boulet'' lorsque l'on considère des messages de faible taille. 

\maraja{Pas de contrôle d'erreur pour UDP}
\textsf{UDP} est utilisé principalement dans la vidéoconférence ou le streaming. Il ne possède qu'un contrôle d'intégrité partiel des données, l'ordre des messages n'est pas contrôlé et rien ne peut assurer qu'une information transmise arrive à son destinataire. A ce titre on qualifie ce protocole de non sûr. Cependant il est très simple dans son fonctionnement. 

Alors que \maraja{TCP} nécessite l'échange d'au minimum 16 paquets contenant au minimum 12 octets chacun pour transmettre l'information \textsf{ASCII} ``bonjour'' \textsf{UDP} n'en nécessite qu'un seul. A titre de comparaison voici sur la figure \ref{dtgudp} les datagrammes de ces deux protocoles en (a) pour \textsf{TCP} et en (b) pour \textsf{UDP}. 

\fig{dtgudp}{Comparaison entre les datagrammes TCP(a) et UDP(b)}

Pour établir un ordre de grandeur des paquets à transférer, il suffit d'énumérer les informations à transmettre dans un paquet standard. Ce paquet concerne le transfert d'une structure \emph{SNVT\_switch}. 

\begin{itemize}
\item	Structure SNVT\_switch
\subitem	value($8[bits]$)
\subitem	state($8[bits]$)
\item	Direction ($1[bit]$)
\item	En-tête LTP ($16[bits]$)		
\end{itemize}

\maraja{UDP est le vainqueur}
On arrive à un total d'un peu plus de $6$ octets. L'utilisation de \textsf{TCP} requiert l'échange de près de $577$ octets pour transmettre ce paquet minimal. \textsf{UDP} en requiert moins de $15$. Inutile maintenant, d'effectuer un calcul du rapport des performances. \textsf{UDP} l'emporte largement.  

\section{Structure des messages}
Après quelques jours d'études il a été défini que l'on peut avoir recours à $7$ types de transaction différentes. A chacune est associée un mnémonique.  

\subsection{SNVT}
Type de message permettant d'échanger l'état de variables réseau LonWorks. Ce sont les structures \textsf{SNVT} issue du code \textsf{C} qui seront transmise dans leur format brut.  Le message inclus une information de direction, de type de structure transférée et surtout d'un identifiant de la variable.

\subsection{CONFIG}
L'échange des paramètres de configurations entre les \textsf{TP} et le \textsf{SERVEUR} vont transiter par ce type de paquet. Il peut s'agir d'une demande de changement d'interface active sur un \textsf{TP}, d'une mise à jour du nom du \textsf{TP} ou d'une requête quant à la taille de l'écran du \textsf{TP}. 

\subsection{PING}
Est un équivalent à la commande \textsf{PING} du protocole \textsf{ICMP}. Il permet d'une part de vérifier que le démon interrogé est bien fonctionnel et d'autre part d'évaluer le temps de transmission entre deux machines LonTouch. 

\subsection{FTP}
Ce type de message joue le rôle d'enveloppe pour l'utilisation du protocole \textsf{VTFTP} permettant l'envoi des interfaces graphiques du \textsf{SERVEUR} aux \textsf{TP}. 

\subsection{RSA}
Certains messages LonTouch peuvent s'avérer confidentiels. Aussi, il à été jugé important de permettre l'échange par le biais de ce type de message de clés de chiffrage. Il s'agit d'un chiffrage du type clé privée, clé publique. 

\subsection{IDENTIFY}
Afin de faciliter l'installation d'un nouveau \textsf{TP}, le procédé d'identification automatique effectué par le serveur est véhiculé par l'intermédiaire de ce type de paquets. Lorsqu'un \textsf{TP} se voit être connecté au réseau et qu'il n'est pas installé, il diffuse en mode \emph{broadcast} un message \textsf{IDENTIFY} que le \textsf{SERVEUR} pourra traiter.

\subsection{ACK}
Chacun des ces types de messages feront l'objet d'accusés de réception. \textsf{UDP} étant un protocole non fiable, il est nécessaire de s'assurer qu'un message à correctement abouti. 

\section{En-tête LTP/UDP}
\maraja{Longueur des paquets limités}
La plus petite unité évaluable par le démon est le bit. Cependant, il est plus facile de raisonner en matière d'octet. C'est pour cette raison que le protocole définit des blocs de 1 octet éventuellement subdivisés en bits. Le premier octet de l'en-tête \textsf{LTP/UDP} est le type de service. Il peut prendre les valeurs de 1 à 7. Il s'agit des messages vus à la section précédente. Le second octet définit un motif spécifique, permettant d'accroître un peu la sécurité du système. Il peut permettre par exemple de travailler dans un même réseau avec plusieurs systèmes LonTouch , chacun composé de son \textsf{SERVEUR} et de ses \textsf{TP}.  Viennent ensuite 4 drapeaux. Le premier spécifie s'il s'agit d'un message nécessitant un accusé de réception ou non. Le second indique si le contenu du message est chiffré. Le troisième indique si le message est de priorité haute ou basse. Enfin, le quatrième définit si il s'agit d'une requête ou d'une simple transmission. Dans le cas d'un message avec accusé, un troisième octet d'en-tête spécifie un numéro d'accusé. Sinon l'en-tête ne fait que $2$ octets de long. Viennent ensuite les données. Un datagramme \textsf{LTP} peut avoir au maximum $228$ octets de long pour assurer la compatibilité avec le réseau LonWorks. Ainsi les données auront une longueur maximum de $226$ octets pour un service non accusé et $225$ octets pour un service accusé. 

La figure \ref{datagramme} présente l'en-tête \textsf{LTP} de façons certainement plus clair. 

\fig{datagramme}{Datagramme LonTouch dans ses deux modes}

\section{Tables de correspondances de l'en-tête LTP/UDP}
Voici les tables de correspondances entre les différents types de service et leurs valeurs numériques ainsi qu'une définition plus simple du deuxième octet de l'en-tête

\begin{tabularx}{\textwidth}{|c|X|p{8cm}|}
	\hline
	0 &\textsf{IDENTIFY}& Paquet d'identification permettant aux \textsf{TP} de s'annoncer auprès du \textsf{SERVEUR}.\\
	\hline	
	1 &\textsf{PING}& Il peut arriver qu'une machine cherche à connaître le temps d'une communication, les paquets de type \textsf{PING} permettent de calculer ce temps. \\
	\hline	
	2 &\textsf{CONFIG}& L'échange de données concernant la configuration de l'installation véhiculent par ces paquets\\
	\hline	
	3 &\textsf{SVNT}& Il s'agit du paquet qui sera le plus utilisé. Il permet de mettre à jour, de demander une valeur de variable réseau\\
	\hline	
	4 &\textsf{FTP}& Le téléchargement des interfaces du \textsf{SERVEUR} aux \textsf{TP} passent par ce type de paquets \\
	\hline	
	5 &\textsf{RSA}& Un mécanisme de chiffrage pourra être utilisé. Bien que LonTalk dispose d'une telle fonctionnalité, cette dernière n'est pas utilisable sur un réseau Ethernet. \\
	\hline	
	6 &\textsf{ACK}& Les accusés de réceptions véhicules par l'intermédiaire de ces paquets\\
	\hline	
\end{tabularx}

Les flags:\par
\begin{tabularx}{\textwidth}{|c|X|p{8cm}|}
	\hline
	0 & \textsf{ACK} & Demande d'accusé\\
	\hline      	
	1 & \textsf{ECD} & Paquet chiffré\\
	\hline      	
	2 & \textsf{PR} & Priorité. Lorsque ce bit est activé le paquet sera placé en tête de la file d'attente. Lorsque il est inhibé, il sera placé en queue. \\
	\hline      	
	3 & \textsf{NA} & Non attribué.\\
	\hline      	
	4-7 & \textsf{PATTERN} & Ce motif permet d'accroitre la reconnaissance d'un datagramme \LonTouch. 	\\
	\hline	
\end{tabularx}

\section{Mécanisme d'accusés de réception}
Le système d'accusé de réception est relativement simple dans son fonctionnement. Chaque paquet envoyé avec une demande d'accusé est pourvu d'un numéro. Ce dernier est incrémenté à chaque envoi d'un message nécessitant un accusé. Etant codé sur $8$ bits, le numéro de référence effectuera un saut en passant de la valeur $255$ à $0$. 

Un temps d'attente correspondant à la durée du plus long \textsf{PING} multiplié par un facteur $2$ est défini. Lorsque l'attente est écoulée, le message est envoyé à nouveau. Au bout de $3$ essais, l'envoi est annulé, est une erreur est signalée. 

La figure \ref{ack} illustre le procédé d'acquittement de \textsf{LTP/UDP}.  

\fig{ack}{Mécanisme d'aquittement du protocole}  

\section{Le protocole en détails}

\subsection{Service SNVT}
Ce type de service se compose d'un en-tête de 2 octets correspondant à l'identification d'une variable. Il s'agit d'un octet définissant le numéro de \textsf{GI} et d'un octet pour le numéro de la variable. Le premier bit de l'en-tête est réservé pour indiquer la direction de la variable. Un troisième octet défini le type de \textsf{SNVT} de la variable concernée. Bien que ce dernier argument ne soit pas indispensable puisque cette information peut être retrouvée à l'aide de l'identifiant de variable, elle facilite la tâche de décodage par le démon. La figure \ref{dtgsnvt} présente graphiquement l'allure du datagramme et la table \ref{tblsnvt} la découpe binaire de l'en-tête. 

\fig{dtgsnvt}{En-tête SNVT} 

\begin{table}
\begin{tabularx}{\textwidth}{|c|X|}
\hline
1 & \textsf{server\_address} \\
\hline
2 & \textsf{screen\_size} \\
\hline
3 & \textsf{active\_interface} \\
\hline
4 & \textsf{list\_interfaces} \\
\hline
5 & \textsf{upload\_interface} \\
\hline
6 & \textsf{energy\_mode} \\
\hline
\end{tabularx}
\caption{\label{tblsnvt}Configuration}
\end{table}

\subsection{Service CONFIG}
Le type config ne contient qu'un seul octet d'en-tête. La table de correspondance [reftable] fait référence aux différentes commandes de configuration.  La figure \ref{dtgsnvt} présente l'allure du datagramme. 


\begin{description}

\item[\textsf{server\_address}]\mbox{}\linebreak
Cette commande est envoyée par le serveur à tous les TP lorsqu'il change d'adresse IP. L'adresse est codée sur 4 octets. Le système n'est pas prévu pour IPv6. 

\item[\textsf{screen\_size }]\mbox{}\linebreak
Permet de déterminer quelle est la taille de l'écran d'un TP. Elle reçoit 4 octets de données. Les deux premiers indiquent la composante horizontale et les deux derniers la composante verticale. 

\item[\textsf{active\_interface}]\mbox{}\linebreak
Lorsqu'un GI est activé sur un TP depuis le WEBGUI. Une commande active\_interface est envoyé avec l'identifiant du GI codé sur 1 octet. LTP ne supporte pas plus de 255 interfaces graphiques. 

\item[\textsf{list\_interface}]\mbox{}\linebreak
Permet au SERVEUR de recevoir une liste des interfaces déjà téléchargée dans un TP. Le détail de la commande n'a pas encore été établi.

\item[\textsf{upload\_interface}]\mbox{}\linebreak
La commande est envoyée par le serveur pour indiquer à un TP qu'il va prochainement recevoir une interface graphique par le biais du protocole VTFTP. Le détail de la commande n'a pas encore été établi.

\item[\textsf{energy\_mode}]\mbox{}\linebreak
Le rétro-éclairage des TP peut-être configuré pour s'éteindre au bout d'un certain temps. Ce temps est indiqué en minute codé sur 1 octet. 

\end{description}

\begin{tabular}{|c|l|}
\hline
1 & \textsf{server\_address} \\
\hline
2 & \textsf{screen\_size} \\
\hline
3 & \textsf{active\_interface} \\
\hline
4 & \textsf{list\_interfaces} \\
\hline
5 & \textsf{upload\_interface} \\
\hline
6 & \textsf{energy\_mode} \\
\hline
\end{tabular}

\subsection{VTFTP}
VTFTP est un protocole élaboré durant ce travail de diplôme. L'en-tête de ce protocole ne se compose que d'un octet correspondant à l'une des commandes définies ci-dessous et par la table [reftable]. Un transfert de données par VTFTP utilise LTP/UDP en mode non acquitté. 

\begin{description}

\item[\textsf{NULL}]\mbox{}\linebreak
	Il s'agit là d'une commande vide. Elle n'est pas utilisée autrement que pour du débogage.

\item[\textsf{INIT}]\mbox{}\linebreak	
	Est envoyé lors de l'initialisation d'un transfert. 
	
\item[\textsf{ACK}]\mbox{}\linebreak
	Permet d'accuser une commande VTFTP. Le type de service VTFTP n'est jamais acquitté par LTP. 

\item[\textsf{DATA}]\mbox{}\linebreak
	Cette commande permet l'envoi d'un fragment de fichier.

\item[\textsf{FIN}]\mbox{}\linebreak
Utilisée après avoir envoyé un bloc de paquets DATA. La commande marque la fin d'un bloc de données. Elle informe le receveur de la somme de contrôle du bloc de donnée. 

\item[\textsf{FILE}]\mbox{}\linebreak
	Envoyée juste après la commande SIZE. Ce paquet renseigne sur le nom du fichier transféré.

\item[\textsf{SIZE}]\mbox{}\linebreak
	Est envoyée juste après la commande INIT. Ce paquet renseigne la taille du fichier transféré.

\item[\textsf{LOST}]\mbox{}\linebreak
	Ce paquet est envoyé par le receveur pour indiquer qu'il n'a pas reçu tous les paquets DATA d'un bloc de donnée

\item[\textsf{ERR}]\mbox{}\linebreak
Est envoyée par le receveur pour indiquer que la somme de contrôle calculée ne correspond pas à celle reçu avec le paquet FIN.

\item[\textsf{END}]\mbox{}\linebreak
	Est envoyée par le serveur pour signaler la fin d'un envoi (réussite ou non).
 
\end{description}

\begin{tabular}{|c|l|}
\hline
0 & \textsf{NULL} \\
\hline
1 & \textsf{INIT } \\
\hline
2 & \textsf{ACK } \\
\hline
3 & \textsf{DATA} \\
\hline
4 & \textsf{FIN} \\
\hline
5 & \textsf{FILE} \\
\hline
6 & \textsf{SIZE} \\
\hline
7 & \textsf{LOST} \\
\hline
8 & \textsf{ERR} \\
\hline
9 & \textsf{END} \\
\hline
\end{tabular}

La figure [reffigure] présente un diagramme d'échange utilisé par VTFTP. 

\subsection{IDENTIFY}
Ce service ne se compose d'aucun en-tête. Le fonctionnement exact n'a pas encore été ni testé, ni défini. 

\subsection{ACK}
La structure des messages ACK est donnée par la figure [reffigure] et la table [reftable]. 

\subsection{RSA}
Faute de temps, ce type de service n'a pas pu être étudié lors de ce travail de diplôme.  

\subsection{Le problème de l'endianness}
En informatique lorsqu'une donnée est représentée sur plusieurs octets, il y a plusieurs manières de les ordonner en mémoire ou dans le canal de communication. Cet ordre fait l'objet de conventions arbitraires. Alors que certaines langues s'écrivent de gauches à droite d'autres s'écrivent de droite à gauche. En informatique il existe principalement 2 types de conventions: 

\begin{itemize}
	\item	\emph{big-endian}
	\item	\emph{little-endian}
\end{itemize}

Dans un format \emph{big-endian} ce sont d'abord les octets de poids fort qui sont représentés en mémoire ou dans le canal de communication alors que dans le format \emph{little-endian} c'est l'inverse. La figure [reffigure] montre la représentation mémoire pour un INTEGER de 16[bits] en (a) pour le \emph{big-endian} et en (b) pour le \emph{little-endian}. 

De toute évidence, ce problème de codage peut être une impasse sérieuse pour LTP/UDP puisque le format des paquets est dépendant de l'architecture qui les construits. Une architecture INTEL ou ARM construira des datagrammes selon la convention \emph{little-endian} alors qu'une architecture MOTOROLA utilisera la convention \emph{big-endian}. Le problème c'est que des datagrammes issus de ces différentes architectures ne se comprendront pas entre eux ou pire, elles croiraient se comprendre mais les données interprétées seraient fausses. 

Notons, pour compliquer encore le problème que LonWorks travaille exclusivement en \emph{big-endian} et que la majorité des périphériques LonTouch étant des PC basés sur des architectures i386 travaillent en \emph{little-endian}.  

Le problème avec LonWorks peut, néanmoins, être résolu par des opérations de conversion. Cependant ces opérations ne fonctionnent que si le système source utilise la convention \emph{little-endian}. 
 
\section{Protocole LTP/HTTP}
Entre-aperçu au chapitre [refchapter], ce protocole est utilisé pour des échanges de donnée entre le SERVEUR et les CLIENTS et dans les TP entre le démon et le navigateur. 

\subsection{Format des requêtes}
Une requête se compose d'une URL source par exemple http://www.lontouch.ch/ puis d'un nom de script suivi d'un point d'interrogation après lequel viennent les différents paramètres séparés les uns des autres par un et commercial. Le protocole LTP/HTTP nécessite un minimum d'un paramètre et la quantité totale de paramètres et limitée par la taille d'une requête GET définie par HTTP. 

\subsection{Envoi de variable(s)}
L'envoi des données du navigateur au démon utilise ce type de requête. 

\textbf{Nom de script:} \\
\begin{itemize}
	\item \textsf{snvt.text?}
	\item \textsf{snvt.js?}
	\item \textsf{snvt.php?}
	\item \textsf{snvt.xml?}
\end{itemize}

Répond "SUCCESS" en cas de réussite et "FAILED" en cas d'échec.

\textbf{Premier paramètre obligatoire:} \\

\begin{itemize}
	\item \textsf{gi}
\end{itemize}

Correspond au numéro de l'interface graphique qui effectue la soumission de variables

\textbf{Paramètres suivants:} \\

\begin{itemize}
	\item \textsf{var.prop}
\end{itemize}

\emph{var} correspond au nom de la variable et \emph{prop} au nom de la propriété à modifier

\textbf{Exemples:} \\

\url{http://www.lontouch.ch/snvt.js?gi=4&lamp1.state=1&lamp1.value=45&lamp2.state=0&lamp2.value=109} \\
\url{http://www.lontouch.ch/snvt.js?gi=4&lamp1.state=true&lamp1.value=118&lamp2.state=false&lamp2.value=112}

\textbf{Restrictions:} \\

Le nombre de paramètres est limité par la taille maximum d'un URL.

\subsection{Demande de l'état des variables} 
L'état des variables relatives à une interface graphique peuvent être demandées au serveur à l'aide de ce type de requête.  

\textbf{Nom de script:} \\
\begin{itemize}
	\item \textsf{snvt.text?}
	\item \textsf{snvt.js?}
	\item \textsf{snvt.php?}
	\item \textsf{snvt.xml?}
\end{itemize}

Répond en fonction du format souhaité, voir la section format des réponses.  

\textbf{Premier paramètre obligatoire:} \\

\begin{itemize}
	\item \textsf{update}
\end{itemize}

indique au serveur qu'une mise à jour de l'état des variables est demandée

\textbf{Second paramètre obligatoire:} \\

\begin{itemize}
	\item \textsf{gi}
\end{itemize}

Correspond au numéro de l'interface graphique qui effectue la soumission de variables

\textbf{Exemples:} \\

\url{http://www.lontouch.ch/snvt.js?update&gi=11} \\
\url{http://www.lontouch.ch/snvt.php?update&gi=2} \\

\textbf{Restrictions:} \\

Aucunes restrictions ne sont à formuler pour ce type de requête. 

\subsection{Mode d'administration} 

\textbf{Nom de script:} \\
\begin{itemize}
	\item \textsf{admin?}
\end{itemize}

Répond en fonction du type de commande \\

\textbf{Premier paramètre obligatoire:} \\

\begin{itemize}
	\item \textsf{command}
\end{itemize}

Où \emph{command} correspond au nom de la commande à envoyer. \\

\textbf{Paramètres suivants:} \\

Les paramètres supplémentaires diffèrent selon le type de commande envoyée.  \\

\textbf{Exemples:} \\

\url{http://www.lontouch.ch/admin?login} \\
\url{http://www.lontouch.ch/admin?gethostname} \\
\url{http://www.lontouch.ch/admin?servicepin} \\

\textbf{Restrictions:} \\

Une requête en mode administration ne peut être effectuée que sur l'adresse IP locale. 

\subsection{Format des réponses}
Il est considéré ici qu'il s'agit de réponse à une requête passée au script \emph{snvt}.

\subsubsection{Formatage JavaScript}
Le format JavaScript suit toujours le modèle suivant: 

\begin{lstlisting}
variable1: {
	prop1: valeur1
	prop2: valeur2 
	...
}
variable2: {
	prop1: valeur1
	prop2: valeur2 
	...
}
...
\end{lstlisting}

Le nombre de variables transmises dépend de la quantité de variables définies pour le GI concerné. 

\subsubsection{Formatage PHP}
Le formatage PHP utilise le format de sérialisation de tableau PHP disponible par la commande serialize. Le format des tableaux PHP transmis est le suivant: 

\begin{lstlisting}
array( 
   array("variable1" =  array("prop1" = "valeur1", "prop2" = "valeur2", ...), ...)
)
\end{lstlisting}

Pour cette structure un résultat de la forme suivante sera reçu: 

\begin{lstlisting}a:1;a1;s9:variable1;a:2:s:5:prop1;s:6:valeur1;s:5:prop2;s:6:valeur2;
\end{lstlisting}

\subsubsection{Formatage XML}
Pour l'instant encore aucun type de formatage XML n'a été défini.

\subsubsection{Formatage TEXT}
Le format TEXT suit toujours le modèle suivant: 

\begin{leftbar}variable1:
~~~prop1 = valeur1
~~~prop2 = valeur2
~~~...
variable2: 
~~~prop1 = valeur1
~~~prop2 = valeur2
~~~...
...
\end{leftbar}


\subsection{La sécurité et LTP/HTTP}
Ainsi décrit, le protocole LTP/HTTP ne comprend aucun dispositif de chiffrage ou d'authentification. Cependant un mécanisme peut être envisagé en utilisant un numéro de session. Il s'agit d'un paramètre véhiculé par la méthode POST de HTTP correspondant à un identifiant retransmis automatiquement par le navigateur lors des différentes requêtes. Cette identifiant est perdu lorsque l'utilisateur quitte le navigateur ou lorsqu'un timeout est dépassé. Cette alternative peut permettre de reconnaître un utilisateur d'un autre. Les accès CLIENTS devraient par la suite fonctionner sur ce procédé. 
